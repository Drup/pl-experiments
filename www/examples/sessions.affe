## Session types
#
# This follow the encoding by Luca Padovani in
# A simple library implementation of binary sessions
# See http://www.di.unito.it/~padovani/Software/FuSe/FuSe.html

# The either type is useful for choices
type ('a: 'k, 'b: 'k) either = Left of 'a | Right of 'b

## Session type primitives
#
# These should be defined in term of lower level network primitives.
# Here, we just state them without any implemnetation

# First, a typed channel.
# `lin` specifies that this channel must be used linearly.
# This is the only linearity annotation in the whole file
type ('a : _, 'b: _) st : lin

type empty

# The various functions on channels. See Padonvani's paper for the
# explanations of the encoding
val receive:
  \ ('a:_)('b:_)('m:'k).
  ('m * ('a, 'b) st, empty) st -> 'm * ('a, 'b) st
val send :
  \ ('a:_)('b:_)('m:'k).
  'm -> (empty, 'm * ('a, 'b) st) st -{'k}> ('b, 'a) st
val create :
  \ ('a:_) ('b:_).
  unit -> ('a, 'b) st * ('b, 'a) st
val close : (empty, empty) st -> unit
val select :
  \ ('a:_)('b:_)('m:_).
  (('a, 'b) st -> 'm) -> (empty, 'm) st -> ('b, 'a) st
val branch : \ ('m:_). ('m, empty) st -> 'm

## Protocol implementation
#
# These directly follow the basic examples.

let op_client ep x y =
  let ep = send x ep in
  let ep = send y ep in
  let (result, ep) = receive ep in
  let u = close ep in
  result

let add_service ep =
  let (x, ep) = receive ep in
  let (y, ep) = receive ep in
  let ep = send (x + y) ep in
  close ep

let dec_service ep =
  let (x, ep) = receive ep in
  let ep = send (x - 1) ep in
  close ep

let math_service ep =
  let b = branch ep in
  match b with {
  | Left x -> add_service x
  | Right x -> dec_service x
  }

let main1 () =
  let (a, b) = create () in
  let () = math_service a in
  let b = select Left b in
  op_client b 1 2

let main2 () =
  let (a, b) = create () in
  let () = math_service a in
  let ep = select Right b in
  let ep = send 4 ep in
  let (result, ep) = receive ep in
  let () = close ep in
  result